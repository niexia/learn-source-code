<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue.js 3 的优化 | 源码学习</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/learn-source-code/favicon.ico">
    <meta name="description" content="Vue | React 源码学习">
    
    <link rel="preload" href="/learn-source-code/assets/css/0.styles.c8f043b9.css" as="style"><link rel="preload" href="/learn-source-code/assets/js/app.e31e0db2.js" as="script"><link rel="preload" href="/learn-source-code/assets/js/2.0f9babf1.js" as="script"><link rel="preload" href="/learn-source-code/assets/js/3.e50c4eba.js" as="script"><link rel="preload" href="/learn-source-code/assets/js/4.82133233.js" as="script"><link rel="preload" href="/learn-source-code/assets/js/5.601c0259.js" as="script"><link rel="prefetch" href="/learn-source-code/assets/js/10.75239088.js"><link rel="prefetch" href="/learn-source-code/assets/js/11.9ef25918.js"><link rel="prefetch" href="/learn-source-code/assets/js/12.f679cde6.js"><link rel="prefetch" href="/learn-source-code/assets/js/13.327c58a4.js"><link rel="prefetch" href="/learn-source-code/assets/js/14.41981968.js"><link rel="prefetch" href="/learn-source-code/assets/js/15.27ff814c.js"><link rel="prefetch" href="/learn-source-code/assets/js/16.45a13a5b.js"><link rel="prefetch" href="/learn-source-code/assets/js/17.f8768f9a.js"><link rel="prefetch" href="/learn-source-code/assets/js/18.7b295381.js"><link rel="prefetch" href="/learn-source-code/assets/js/19.c19b4b5a.js"><link rel="prefetch" href="/learn-source-code/assets/js/20.a5959386.js"><link rel="prefetch" href="/learn-source-code/assets/js/21.2d31fefd.js"><link rel="prefetch" href="/learn-source-code/assets/js/6.baa84aa3.js"><link rel="prefetch" href="/learn-source-code/assets/js/7.ef0c02e4.js"><link rel="prefetch" href="/learn-source-code/assets/js/8.726d0783.js"><link rel="prefetch" href="/learn-source-code/assets/js/9.e75944e9.js">
    <link rel="stylesheet" href="/learn-source-code/assets/css/0.styles.c8f043b9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/learn-source-code/" class="home-link router-link-active"><!----> <span class="site-name">源码学习</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/learn-source-code/vue/" class="nav-link">
  Vue 2
</a></div><div class="nav-item"><a href="/learn-source-code/vue-next/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Vue 3
</a></div><div class="nav-item"><a href="/learn-source-code/react/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="https://niexia.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  个人博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/niexia/learn-source-code" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/learn-source-code/vue/" class="nav-link">
  Vue 2
</a></div><div class="nav-item"><a href="/learn-source-code/vue-next/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Vue 3
</a></div><div class="nav-item"><a href="/learn-source-code/react/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="https://niexia.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  个人博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/niexia/learn-source-code" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>核心实现</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Composition API</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>优化思想</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>总结对比</span> <!----></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue-js-3-的优化"><a href="#vue-js-3-的优化" class="header-anchor">#</a> Vue.js 3 的优化</h1> <p>先看一下 Vue.js 主要的优化内容</p> <h2 id="源码优化"><a href="#源码优化" class="header-anchor">#</a> 源码优化</h2> <ol><li><strong>monorepo</strong></li></ol> <p>主要体现在使用 monorepo 和 TypeScript 管理和开发源码，这样做的目的是提升自身代码可维护性。</p> <p><img src="/learn-source-code/assets/img/vue-next-directory.63df2dac.png" alt="directory"></p> <p>monorepo 把这些模块拆分到不同的 package 中，每个 package 有各自的 API、类型定义和测试。这样使得模块划分更加细化，职责划分更明确方便阅读。</p> <p>另外例如 reactivity 是可以独立于 Vue 来使用的，现在如果我们想用响应式，并不需要去依赖整个 Vue.js。</p> <ol start="2"><li><strong>TypeScript</strong></li></ol> <p>使用类型语言非常有利于代码维护，因为可以在编码期间就做类型检查，很好避免因为类型问题导致的错误。Vue.js 3.0 抛弃了 Flow 改用 TypeScript。TypeScript 提供更好的类型检查，以及类型推导，另外也省去单独维护 .d.ts 的工作。</p> <h2 id="性能优化"><a href="#性能优化" class="header-anchor">#</a> 性能优化</h2> <ol><li><strong>源码体积优化</strong></li></ol> <p>体积越小，意味着加载时间更快，解析的时间也更快。</p> <p>Vue 3.0 首先移除了一些比较冷门的 feature（filter 等），其次，引入 tree-shaking 技术，减少打包 📦 的体积。</p> <p class="nx-tip question">
  为什么说引入 tree-shaking? tree-shaking 的工作原理以及如何引入？
</p> <ol start="2"><li><strong>数据劫持优化</strong></li></ol> <p>Vue.js 区别于 React 的一大特性，就是它的数据是响应式的。DOM 是数据的一种映射，数据发生变化自动更新 DOM，我们只需要关系数据的修改就行。</p> <p>为了实现这个功能，Vue.js 就必须劫持数据的访问和更新。</p> <ul><li>先说 DOM 更新。当数据变化之后，为了自动更新 DOM，那就必须劫持数据更新，这样当数据更新的时候能自动去执行一些逻辑去更新 DOM。</li> <li>那怎么知道要更新哪些 DOM 呢？当渲染 DOM 的时候，肯定需要访问数据，这个时候就可以对它进行劫持，这样内部就建立了依赖，知道数据对应的 DOM 是什么。</li></ul> <p>Vue 2 是通过 <code>Objective.defineProperty</code> 这个 API 来实现数据的支持的：</p> <div class="language-js extra-class"><pre class="language-js"><code>Objective<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 劫持访问</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 触发更新</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>但是这个 API 有个缺陷，<strong>就是必须预先知道要拦截的 key！例如前面的 <code>name</code>，所以它不能检测对象属性的添加和删除</strong>。尽管 Vue 提供了 <code>$set</code>、<code>$delete</code> 来解决这个问题，但是对用户来说还是增加一定的心智负担。</p> <p>也因为这个缺陷，Vue 并不知道你在运行的时候使用哪个属性，所以他需要劫持每一个属性。<strong>要实现这个目的就需要递归遍历整个对象，如果我们的对象比较复杂，嵌套很深，就会有很大的性能负担。</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  data<span class="token operator">:</span> <span class="token punctuation">{</span>
    a<span class="token operator">:</span> <span class="token punctuation">{</span>
      b<span class="token operator">:</span> <span class="token punctuation">{</span>
        c<span class="token operator">:</span> <span class="token punctuation">{</span>
          d<span class="token operator">:</span> <span class="token punctuation">{</span>
            name<span class="token operator">:</span> <span class="token string">'vue'</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为了解决上述的问题，Vue.js 3.0 使用 Proxy API 来做数据劫持：</p> <div class="language-js extra-class"><pre class="language-js"><code>observed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 劫持访问</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 触发更新</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>由于它劫持的是整个对象，自然对对象的属性增加、删除都能检测到。</p> <p>需要注意 Proxy API 并不能监听内部深层次的数据变化，Vue.js 3.0 的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归，这样无疑也在很大程度上提升了性能</p> <p class="nx-tip question">
  既然是真正使用的时候才变成响应式，为什么内部还是需要递归来做响应式？
</p> <ol start="3"><li><strong>编译优化</strong></li></ol> <p>为了更好理解，我们先看一下 Vue 渲染 DOM 的过程</p> <p><img src="/learn-source-code/assets/img/vue-compile.c55d8a9b.png" alt="compile"></p> <p>前面说的数据劫持优化主要在 init 阶段，而 compile 流程可以使用 vue-loader 在编译阶段离线完成。想继续优化，那么我们可以在耗时较多的 patch 阶段想办法！Vue.js 30 也是怎么做的。</p> <p>通过前面的数据劫持之后，Vue.js 2.x 的数据更新触发重新渲染的组件级的。<strong>虽然保证更新的组件最小化，但是单个组件内部依然需要便利整个 vnode 树</strong>。举个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;content&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>p <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;text&quot;</span><span class="token operator">&gt;</span><span class="token keyword">static</span> text<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>p <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;text&quot;</span><span class="token operator">&gt;</span><span class="token keyword">static</span> text<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>p <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;text&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>message<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>p <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;text&quot;</span><span class="token operator">&gt;</span><span class="token keyword">static</span> text<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>p <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;text&quot;</span><span class="token operator">&gt;</span><span class="token keyword">static</span> text<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
</code></pre></div><p>这段代码的整个 diff 过程如下：</p> <p><img src="/learn-source-code/assets/img/vue-diff.b6729dfb.png" alt="diff"></p> <p><strong>实际上只有一个动态节点，所以这里很多 diff 和遍历其实是不需要的，这会导致性能的浪费</strong>。也就是说 vnode 的性能应该和动态节点数量相关，而不是和模板大小正相关。</p> <p>为了解决这个问题 Vue.js 3.0 在模版编译阶段通过对静态模板的分析，编译生产 Block tree。借助 Block tree，Vue.js 将 vnode 的更新性能变为了和动态内容的数量相关，这是一个很大的性能突破！</p> <h2 id="语法优化-composition-api"><a href="#语法优化-composition-api" class="header-anchor">#</a> 语法优化 Composition API</h2> <p>除了源码和性能的优化，Vue.js 3.0 在语法上提供了 Composition API，对我们的代码组织和复用带来很大的好处！</p> <ol><li><strong>优化组织结构</strong></li></ol> <p>基于 Options API 的组件编写方式（逻辑分散）转化为基于组合的编写方式（逻辑收敛）</p> <ol start="2"><li><strong>优化逻辑复用</strong></li></ol> <p>当我们项目复杂的时候，不免的会抽象出一些复用的逻辑。在 2.x 中，我们一般会使用 mixins 去复用逻辑。但是随着 mixins 的复杂层度以及数量的增加，<strong>会存在两个非常明显的问题：命名冲突和来源不明确</strong>。</p> <p>每个 mixin 都可以定义自己的 props、data，很容易就会定义相同的变量。而在组件中，使用不在当前组件定义的变量，也很难知道这些变量实际是在哪里定义的，这就是来源不明确。</p> <p>使用 Composition API 就很好的解决这两个问题。同时它本身就是函数，所以有更好的类型支持。另外，它对 tree-shaking 更加友好，代码更容易压缩。</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/niexia/learn-source-code/edit/master/docs/vue-next/README.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2/20/2022, 5:47:01 AM</span></div></footer> <!----> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/learn-source-code/assets/js/app.e31e0db2.js" defer></script><script src="/learn-source-code/assets/js/2.0f9babf1.js" defer></script><script src="/learn-source-code/assets/js/3.e50c4eba.js" defer></script><script src="/learn-source-code/assets/js/4.82133233.js" defer></script><script src="/learn-source-code/assets/js/5.601c0259.js" defer></script>
  </body>
</html>
